#ifndef A4AA5F91_C34B_4B17_863D_CAC9481DC891
#define A4AA5F91_C34B_4B17_863D_CAC9481DC891

#include <stdbool.h>
#include <stdlib.h>
#include "./Allocator/allocator.h"

/*

Stack and Queue are elementary data structures that have a
common generalization: the double-ended queue (this has
far fewer applications though).

*/

/*

The stack is the simplest of all structures, with an obvious interpretation:
putting objects on the stack and taking them off again, with access possible only to the
top item. For this reason they are sometimes also described as LIFO storage: last in, first out.

Stacks occur in programming wherever we have nested blocks,
local variables, recursive definitions, or backtracking. Typical programming
exercises that involve a stack are the evaluation of arithmetic expressions with
parentheses and operator priorities, or search in a labyrinth with backtracking.

The stack should support at least the following operations:

1. push (obj): Put obj on the stack, making it the top item.
2. pop() : Return the top object from the stack and remove it from the stack.
3. stack_empty() : Test whether the stack is empty.

Also, the realization of the stack has, of course, to give the right values, so we need
to specify the correct behavior of the stack. One method would be an algebraic specification
of what correct sequences of operations and return values are. This has been done
for simple structures like the stack, but even then the specification is not very helpful
in understanding the structure. Instead, we can describe a canonical implementation on
an idealized machine, which gives the correct answer for all correct sequences (no pop
on an empty stack, no memory problems caused by bounded arrays). Assuming that the elements
we want to store on the stack are of type item_t, this could look as follows:

*/

#ifdef CANONICAL_STACK

size_t i = 0;
item_t stack[#INFINITY];

bool stack_empty(void)
{
    return (!i);
}

void push(item_t x)
{
    stack[i++] = x;
}

item_t pop(void)
{
    return stack[--i];
}

#endif

/*

This describes the correct working of the stack, but we have the problem of assuming
both an infinite array and that any sequence of operations will be correct.

A more realistic version might be the following:

*/

#ifdef STACK_ONE

#define MAX_SIZE

size_t i = 0;
item_t stack[MAX_SIZE];

bool stack_empty(void)
{
    return (!i);
}

bool push(item_t x)
{
    if (i < MAX_SIZE)
    {
        stack[i++] = x;
        return true;
    }

    return false;
}

item_t pop(void)
{
    return (stack[i--]);
}

#endif

/*

This now limits the correct behavior of the stack by limiting the maximum
number of items on the stack at one time so it is not really the correct stack we want,
but at least it does specify an error message in the return value if the stack overflow
is reached by one push too many.

This is a fundamental defect of array-based realizations of data structures: they are of
fixed-size, the size needs to be decided in advance, and the structure needs the full size
no matter how many items are really in the structure.

There is a systematic way to overcome these problems for array-based structures, which we will
see, but usually a solution with dynamically allocated memory is preferable.

We specified an error value only for the stack overflow condition, but not
for the stack underflow, because the stack overflow is an error generated by
the structure, which would not be present in an ideal implementation, whereas
a stack underflow is an error in the use of the structure and so a result in the
program that uses the stack as a black box.

Also, this allows us to keep the
return value of pop as the top object from the stack; if we wanted to catch
stack underflow errors in the stack implementation, we would need to return
the object and the error status.

A final consideration in our first stack version
is that we might need multiple stacks in the same program, so we want to
create the stacks dynamically. For this we need additional operations to create
and remove a stack, and each stack operation needs to specify which stack it
operates on. One possible implementation could be the following:

*/

#ifdef STACK_TWO

typedef struct
{
    item_t *base;
    item_t *top;
    size_t size;
} stack_t;

stack_t *create_stack(size_t size)
{
    stack_t *st = (stack_t *)allocate(sizeof(stack_t));
    st->base = (item_t *)allocate(size * sizeof(item_t));

    st->size = size;
    st->top = st->base;

    return (st);
}

bool stack_empty(stack_t *st)
{
    return ((uintptr_t)st->base == (uintptr_t)st->top);
}

bool push(item_t x, stack_t *st)
{
    if ((uintptr_t)st->top < (uintptr_t)st->base + st->size)
    {
        *(st->top) = x;
        st->top += 1;
        return true;
    }

    return false;
}

item_t pop(stack_t *st)
{
    st->top -= 1;
    return *(st->top);
}

item_t top_element(stack_t *st)
{
    return *(st->top - 1);
}

void remove_stack(stack_t *st)
{
    deallocate(st->base);
    deallocate(st);
}

#endif

/*

Again, we include some security checks and leave out others. Our policy
in general is to include those security checks that test for errors introduced
by the limitations of this implementation as opposed to an ideal stack, but
to assume both that the use of the stack is correct and that the underlying
operating system never runs out of memory. We included another operation
that is frequently useful, which just returns the value of the top element without
taking it from the stack.

*/

#endif /* A4AA5F91_C34B_4B17_863D_CAC9481DC891 */
